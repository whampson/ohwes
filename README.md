# ohwes
***ohwes** - Will you ever finish that damn operating system?*

## Build Environment
### Windows (MinGW)
- `PS> winget install msys2.msys2`
- `MSYS> pacman -Syu`
- `MINGW32> pacman -S mingw32/mingw-w64-i686-toolchain`
- `MINGW32> cp /mingw32/bin/mingw32-make.exe /mingw32/bin/make.exe`
- `MINGW32> pacman -S mingw32/mingw-w64-i686-qemu`

Download and extract [i686-elf-tools for Windows](https://github.com/lordmilko/i686-elf-tools/releases/download/7.1.0/i686-elf-tools-windows.zip).
Copy the contents of `bin/`, `i686-elf/`, `lib/`, and `libexec/` to `/mingw32/`.



### macOS/OSX
Execute `$ brew install binutils` then `$ brew install coreutils`.


**TODO: acquiring the i686-elf-tools**

## Building
**ohwes** uses GNU Make for building all source and external tools. The following
assumes you are using bash as your shell.

To set up the build environment and build **ohwes**, run the following from the
repository root:
```
$ source src/scripts/env.sh
$ make
```

To delete binaries and object files generated by the current build:
```
$ make clean
```

To delete all binaries and object files:
```
$ make nuke
```

To output useful variables for debugging your Makefile:
```
$ make debug-make
```

### Build System
The most basic Makefile looks like this:
```make
include $(_MAKEROOT)
```
When invoked via `make`, this will compile all the source in the current
directory. `$(_MAKEROOT)` refers to the master Makefile located at the
repository root, outside of the src/ directory, which contains all the build
infrastructure and must be included in every Makefile.

The above Makefile only compiles source; it does invoke the linker or output
binaries. To build a binary, add a `TARGET` definition before summoning the
make god:
```make
TARGET = my_exe

include $(_MAKEROOT)
```
This will output an executable file named 'my_exe' in the current directory,
built from the source in that directory. To move the file to a common location,
you may use the `$(BIN_DIR)` variable as a path prefix:
```make
TARGET = $(BIN_DIR)/my_exe

include $(_MAKEROOT)
```

Note that the `TARGET` definition appears before the `include` directive. This
is **required** as the `TARGET` variable is a *prerequisite variable* that
affects Makefile behavior. Prerequisite variables affect the control flow of the
master Makefile and thus their existence or absence affects the operations
performed by the Makefile. A complete list of prerequisite variables can be
found below.

In addition to prerequisite variables are *dependent variables*. Dependent
variables are defined by the master Makefile and can be appended or overridden
in child Makefiles, and thus are defined after the `include` directive:
```make
TARGET = $(BIN_DIR)/my_exe

include $(_MAKEROOT)

C_DEFINES += MY_EXE PREFIX=foo
```
This will append the existing `C_DEFINES` with `MY_EXE` and `PREFIX=foo`.
When compiling .c files, `C_DEFINES` is expanded into something resembling
`-DMY_EXE -DPREFIX=foo` and combined with the other C compiler flags. As such,
C defines that specify a value must not include spaces surrounding the '=' sign.

Subdirectories can be compiled by adding a `DIRS` definition, so long as each
subdirectory contains a Makefile:
```make
DIRS = my_feature1 my_feature2
TARGET = $(BIN_DIR)/my_exe

include $(_MAKEROOT)

C_DEFINES += MY_EXE PREFIX=foo
```
This will build the source found in subdirectories named `my_feature1` and
`my_feature2` before building the source in the current directory. Note that
this does not declare the subdirectories as dependencies on the source in
the current directory! **(Feature support for dependencies is coming soon!!)**

#### Prerequisite Variables
* `CODE_BASE`
* `DIRS`
* `ENTRY_POINT`
* `TARGET`

#### Dependent Variables
* `ARCH`
* `AS`
* `AS_FLAGS`
* `AS_DEFINES`
* `AS_WARNINGS`
* `BIN_PATH`
* `CC`
* `C_FLAGS`
* `C_DEFINES`
* `C_WARNINGS`
* `DEBUG`
* `INC`
* `LD`
* `LD_FLAGS`
* `LD_WARNINGS`
* `MKDIR`
* `OBJCOPY`
* `OBJCOPY_FLAGS`
* `OBJ_PATH`
* `RM`
